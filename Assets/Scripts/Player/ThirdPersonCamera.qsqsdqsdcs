using UnityEngine;
using System.Collections;

public class ThirdPersonCamera : MonoBehaviour {
	
	public bool invertedVerticalAxis; //Is the rotation control inverted?
	public float lookHSpeed = 150; //Rotation control sensitivity.
	public float yMinLimit = -20f; //Angle limit when the camera looks down
	public float yMaxLimit = 80f; //Angle limit when the camera looks up
	public float xSpeed = 250.0f; //Aim Mode - horizontal sensitivity.
	public float ySpeed = 120.0f; //Aim mode - vertical sensitivity.
	public float distance = 10.0f;
	public float smooth = 5;
	public LayerMask CompensateLayer;
	public Quaternion rotationOffset = Quaternion.identity;

	private Vector3 targetPosition;
	private Vector3 lookDir; //Tells the cam where to look
	private Vector3 characterOffset = Vector3.zero;
	private float localDeltaTime;
	private float lookH = 0;
	private float x = 0.0f;
	private float y = 50f;
	public float damping = 6.0f;
	private Vector3 offset = new Vector3(0f, 1.3f, 5f);

	[HideInInspector]
	public Transform camTarget; //Ce que la caméra suit

	void Start()
	{
		camTarget = GameObject.FindWithTag ("Player").transform;
	}

	void LateUpdate()
	{
		localDeltaTime = (Time.timeScale == 0) ? 1 : Time.deltaTime / Time.timeScale;
		
		lookDir = camTarget.position - transform.position;
		lookDir.y = 0;
		lookDir.Normalize ();

		//On calcule la direction venant de la caméra et allant vers le joueur, on neutralise l'axe Y, et on normalise pour pouvoir utiliser la magnitude.
		lookDir = characterOffset - transform.localPosition;
		lookDir.y = 0;
		lookDir.Normalize ();
		
		lookH = Input.GetAxis ("LookH");
		transform.RotateAround (camTarget.localPosition, Vector3.up, lookH * lookHSpeed * localDeltaTime);
		
		x += Input.GetAxis("LookH") * xSpeed * 0.02f;
		if (!invertedVerticalAxis){
			y -= Input.GetAxis("LookV") * ySpeed * 0.02f;
		}else{
			y += Input.GetAxis("LookV") * ySpeed * 0.02f;
		}
		
		y = ClampAngle(y, yMinLimit, yMaxLimit);
		
		
		Quaternion rotation = Quaternion.Euler(y, x, 0f);
		
		
		Vector3 position = rotation * new Vector3(0.0f, 0.0f, -distance) + camTarget.position;
		targetPosition = position;

		//Manual rotation around the player when the second stick is moved
		lookH = Input.GetAxis ("LookH");
		transform.RotateAround (camTarget.localPosition, Vector3.up, lookH * lookHSpeed * localDeltaTime);

		Vector3 setPosition = 2 * new Vector3(0.0f, 0.0f, -distance) + camTarget.position;
		transform.position = Vector3.Lerp (transform.position, setPosition, localDeltaTime * smooth);



		#region Aiming at target
		Quaternion rotation = Quaternion.LookRotation(camTarget.position - transform.position);
		rotation *= rotationOffset;
		transform.rotation = Quaternion.Slerp(transform.rotation, rotation, localDeltaTime * damping);
		#endregion
	}
}
